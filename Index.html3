<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Chess Arena Pi — Classic (Dual + Single Board)</title>
<style>
  :root{
    --bg:#3e2723; --fg:#efeadd; --light:#f0d9b5; --dark:#b58863;
    --panel:#1e1e1e; --accent:#6d4c41; --accent2:#8d6e63; --warn:#ff5252;
  }
  body{ margin:0; font-family:Inter,system-ui,Arial; background:var(--bg); color:var(--fg); display:flex; justify-content:center; padding:18px; box-sizing:border-box; }
  #app{ width:100%; max-width:1180px; display:grid; grid-template-columns: 1fr 360px; gap:18px; align-items:start; }
  header{ grid-column:1/-1; text-align:center; margin-bottom:6px }
  h1{ margin:0; font-size:20px }
  .sub{ font-size:12px; opacity:.9; margin-top:6px }

  /* boards layout */
  .boards{ display:flex; gap:12px; flex-wrap:wrap; justify-content:center; }
  .board-wrap{ background:var(--panel); padding:12px; border-radius:12px; border:1px solid rgba(0,0,0,.25); box-shadow:0 10px 30px rgba(0,0,0,0.45) }
  .title{ font-size:14px; margin-bottom:8px; text-align:center }
  .board{ width:384px; height:384px; display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr); border-radius:8px; overflow:hidden; border:4px solid #5d4037; }
  .sq{ display:flex; align-items:center; justify-content:center; user-select:none; cursor:pointer; font-size:36px; }
  .light{ background:var(--light); }
  .dark{ background:var(--dark); }
  .sq.sel{ outline:3px solid gold; outline-offset:-3px; }
  .sq.hint::after{ content:""; width:26%; height:26%; border-radius:50%; background:rgba(90,200,250,.85); display:block; }
  .piece-sprite{ width:88%; height:88%; background-image:url('pieces.png'); background-size:600% 200%; background-repeat:no-repeat; display:block; }
  /* sprite positions (6 x 2) */
  .wK{ background-position:0% 0% } .wQ{ background-position:20% 0% } .wR{ background-position:40% 0% }
  .wB{ background-position:60% 0% } .wN{ background-position:80% 0% } .wP{ background-position:100% 0% }
  .bK{ background-position:0% 100% } .bQ{ background-position:20% 100% } .bR{ background-position:40% 100% }
  .bB{ background-position:60% 100% } .bN{ background-position:80% 100% } .bP{ background-position:100% 100% }

  /* side panel */
  .panel{ background:var(--panel); padding:12px; border-radius:12px; border:1px solid rgba(0,0,0,.25) }
  .players{ display:flex; gap:8px; justify-content:space-between; margin-bottom:10px }
  .player{ flex:1; padding:8px; border-radius:8px; background:#121212; border:1px solid #222; text-align:center }
  .player .label{ font-weight:800; font-size:13px }
  .player .id{ font-size:12px; color:#ccc; word-break:break-all }
  .captured{ min-height:42px; display:flex; gap:6px; flex-wrap:wrap; align-content:flex-start; justify-content:center; margin-top:8px }

  .controls{ display:flex; gap:8px; margin-top:10px; align-items:center; justify-content:space-between }
  button{ background:var(--accent); color:var(--fg); border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700 }
  button.secondary{ background:#5a5a5a }
  #rematchBtn{ background:#3bbf7f; color:#041 }
  #singleToggle{ background:var(--accent2) }

  /* rematch prompt */
  #rematchPrompt{ display:none; margin-top:8px; padding:12px; background:#222; border-radius:10px; text-align:center }

  /* small screens */
  @media (max-width:980px){
    #app{ grid-template-columns: 1fr; }
    .board{ width:320px; height:320px }
  }

  /* confetti canvas */
  #fx{ position:fixed; inset:0; pointer-events:none; z-index:9999 }
</style>
</head>
<body>
  <div id="app">
    <header>
      <h1>♞ Chess Arena Pi — Classic</h1>
      <div class="sub">Classic (FIDE) rules. Toggle single-board for online matches. Uses sprite `pieces.png` if present; falls back to symbols.</div>
    </header>

    <div class="boards" id="boards">
      <div class="board-wrap" id="whiteWrap">
        <div class="title">White View</div>
        <div id="boardWhite" class="board" aria-label="White board"></div>
        <div class="captured" id="capturedWhite"></div>
      </div>

      <div class="board-wrap" id="blackWrap">
        <div class="title">Black View</div>
        <div id="boardBlack" class="board" aria-label="Black board"></div>
        <div class="captured" id="capturedBlack"></div>
      </div>
    </div>

    <div class="panel">
      <div class="players">
        <div class="player">
          <div class="label">Player White</div>
          <div id="player1Id" class="id">(local)</div>
          <div id="clockW" style="font-weight:900;margin-top:6px">05:00</div>
        </div>
        <div class="player">
          <div class="label">Player Black</div>
          <div id="player2Id" class="id">(local)</div>
          <div id="clockB" style="font-weight:900;margin-top:6px">05:00</div>
        </div>
      </div>

      <div class="controls">
        <div style="display:flex;gap:8px">
          <button id="flipBtn" class="secondary">Flip</button>
          <button id="offerDraw" class="secondary">Offer Draw</button>
          <button id="resignBtn" class="secondary">Resign</button>
        </div>

        <div style="display:flex;gap:8px">
          <button id="rematchBtn">Request Rematch</button>
          <button id="singleToggle">Single-Board: Off</button>
        </div>
      </div>

      <div id="rematchPrompt"></div>

      <div style="margin-top:8px;font-size:12px;opacity:.9">Multiplayer: <span id="mpStatus">local/offline</span></div>
    </div>
  </div>

  <canvas id="fx"></canvas>

<script>
/* ================== CONFIG ================== */
/* If you have a WebSocket relay server set this; otherwise leave empty and offline fallback/local dual-board will be used. */
const MULTIPLAYER_WS_URL = ""; // e.g. "wss://your-server.example"

/* Game settings */
const START_CLOCK = 300; // seconds per player (5:00)
const REMATCH_AUTO_CANCEL = 5; // seconds auto-cancel rematch request

/* My side for single-board mode (set 'w' or 'b' later when connecting online). Default none -> show both boards */
let mySide = null; // 'w' or 'b' or null for dual-board local mode

/* ========== load chess.js (CDN) ========== */
function ensureChessLib(cb){
  if(window.Chess) return cb();
  const s = document.createElement('script');
  s.src = "https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.min.js";
  s.onload = cb; document.head.appendChild(s);
}

/* ========== global UI refs ========== */
const boardWhiteEl = document.getElementById('boardWhite');
const boardBlackEl = document.getElementById('boardBlack');
const capturedWhiteEl = document.getElementById('capturedWhite');
const capturedBlackEl = document.getElementById('capturedBlack');
const rematchBtn = document.getElementById('rematchBtn');
const rematchPromptEl = document.getElementById('rematchPrompt');
const mpStatusEl = document.getElementById('mpStatus');
const singleToggle = document.getElementById('singleToggle');
const fxCanvas = document.getElementById('fx');
const ctxFx = fxCanvas.getContext('2d');

/* Sound hooks (simple beeps) */
const SND = (()=>{ let ctx; function beep(f=600,t=0.06){ try{ ctx = ctx || new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(), g=ctx.createGain(); o.type='sine'; o.frequency.value=f; g.gain.value=0.05; o.connect(g); g.connect(ctx.destination); o.start(); setTimeout(()=>o.stop(), t*1000); }catch(e){} } return { move:()=>beep(640), capture:()=>beep(260), check:()=>beep(900), win:()=>{beep(880,0.12); setTimeout(()=>beep(988,0.12),140);}} })();

/* Confetti simple */
const Confetti = (()=>{ let parts=[]; let running=false; function resize(){ fxCanvas.width = innerWidth; fxCanvas.height = innerHeight; } addEventListener('resize', resize); resize();
  function burst(n=100){
    parts=[]; for(let i=0;i<n;i++) parts.push({ x: innerWidth/2 + (Math.random()*200-100), y: innerHeight*0.2, vx:(Math.random()*2-1)*6, vy:(Math.random()*-6-1), s:Math.random()*6+4, a:Math.random()*Math.PI, col:`hsl(${Math.random()*360},80%,60%)`});
    if(!running){ running=true; requestAnimationFrame(loop); }
  }
  function loop(){
    ctxFx.clearRect(0,0,fxCanvas.width,fxCanvas.height);
    for(const p of parts){ p.vy += 0.25; p.x += p.vx; p.y += p.vy; p.a += 0.2; ctxFx.save(); ctxFx.translate(p.x,p.y); ctxFx.rotate(p.a); ctxFx.fillStyle=p.col; ctxFx.fillRect(-p.s/2,-p.s/2,p.s,p.s); ctxFx.restore(); }
    parts = parts.filter(p=>p.y < innerHeight + 50);
    if(parts.length) requestAnimationFrame(loop); else running=false;
  }
  return { burst };
})();

/* ========== GAME STATE ========== */
let game = null;
let selected = null;
let usingWS = false;
let ws = null;

/* clocks */
let clocks = { w: START_CLOCK, b: START_CLOCK };
let clockInterval = null;
let lastTick = performance.now();
let gameOver = false;

/* UI utilities */
function formatTime(s){ s = Math.max(0, Math.floor(s)); const m = Math.floor(s/60); const sec = s%60; return `${m}:${String(sec).padStart(2,'0')}`; }
function updateClockDisplays(){ document.getElementById('clockW').textContent = formatTime(clocks.w); document.getElementById('clockB').textContent = formatTime(clocks.b); }

/* piece rendering: attempt sprite, otherwise use unicode fallback */
const UNICODE = { p:'♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚', P:'♙', R:'♖', N:'♘', B:'♗', Q:'♕', K:'♔' };
function makePieceEl(piece){
  // piece param is object {type:'p', color:'w'}
  // try sprite: create div.piece-sprite + class wP/bK etc
  const el = document.createElement('div');
  el.style.width = '92%'; el.style.height = '92%'; el.style.display='flex'; el.style.alignItems='center'; el.style.justifyContent='center';
  // check if pieces.png exists by trying to load it (cached flag)
  if(window.__pieces_png_loaded === undefined){
    // attempt preloading once
    const img = new Image();
    img.onload = ()=> window.__pieces_png_loaded = true;
    img.onerror = ()=> window.__pieces_png_loaded = false;
    img.src = 'pieces.png';
    window.__pieces_png_loaded = null; // pending
  }
  if(window.__pieces_png_loaded === true){
    const sp = document.createElement('div');
    sp.className = 'piece-sprite ' + (piece.color === 'w' ? 'w' : 'b') + piece.type.toUpperCase();
    sp.style.width='100%'; sp.style.height='100%';
    el.appendChild(sp);
  } else if(window.__pieces_png_loaded === null){
    // if unknown, use unicode temporarily, sprite will appear after load if present on next render
    el.textContent = UNICODE[piece.color === 'w' ? piece.type.toUpperCase() : piece.type];
    el.style.fontSize = '38px';
  } else {
    // no sprite, fallback to unicode
    el.textContent = UNICODE[piece.color === 'w' ? piece.type.toUpperCase() : piece.type];
    el.style.fontSize = '38px';
  }
  return el;
}

/* Build grid squares for a board element (a8..h1 order in DOM) */
function createBoardGrid(boardEl){
  boardEl.innerHTML = '';
  const files = ['a','b','c','d','e','f','g','h'];
  for(let r=8;r>=1;r--){
    for(let c=0;c<8;c++){
      const sq = document.createElement('div');
      const file = files[c];
      const alg = file + r;
      sq.dataset.square = alg;
      const idx = (8 - r) + c; // not used
      const isDark = ((8 - r) + c) % 2 === 1;
      sq.className = 'sq ' + (isDark ? 'dark' : 'light');
      boardEl.appendChild(sq);
    }
  }
}

/* Render both boards (or single board depending on mySide) */
function renderBoards(){
  // render helper
  const fillBoard = (boardEl, perspective) => {
    boardEl.querySelectorAll('.sq').forEach(sq => sq.innerHTML = '');
    // order of DOM is a8..h1; perspective doesn't change DOM, just content
    const squares = [...boardEl.querySelectorAll('.sq')];
    for(const sq of squares){
      const alg = sq.dataset.square;
      const piece = game.get(alg);
      if(piece){
        const el = makePieceEl({ type: piece.type, color: piece.color });
        sq.appendChild(el);
      }
    }
  };

  // if single-board: show only relevant board; else show both
  if(mySide === 'w'){
    document.getElementById('whiteWrap').style.display='block';
    document.getElementById('blackWrap').style.display='none';
    fillBoard(boardWhiteEl, 'w');
  } else if(mySide === 'b'){
    document.getElementById('whiteWrap').style.display='none';
    document.getElementById('blackWrap').style.display='block';
    fillBoard(boardBlackEl, 'b');
  } else {
    document.getElementById('whiteWrap').style.display='block';
    document.getElementById('blackWrap').style.display='block';
    fillBoard(boardWhiteEl, 'w');
    fillBoard(boardBlackEl, 'b');
  }
  updateCapturedDisplays();
  updateClockDisplays();
}

/* highlight legal moves for selected square across both boards */
function highlightMovesFrom(square){
  clearHighlights();
  const moves = game.moves({ square, verbose:true });
  if(!moves || !moves.length) return;
  document.querySelectorAll(`[data-square="${square}"]`).forEach(el => el.classList.add('sel'));
  moves.forEach(m=>{
    document.querySelectorAll(`[data-square="${m.to}"]`).forEach(el=> el.classList.add(m.captured ? 'cap' : 'hint'));
  });
}

/* remove all highlights */
function clearHighlights(){
  document.querySelectorAll('.sq').forEach(sq => sq.classList.remove('sel','hint','cap'));
}

/* captured displays built from history */
function updateCapturedDisplays(){
  capturedWhiteEl.innerHTML = ''; capturedBlackEl.innerHTML = '';
  const hist = game.history({ verbose:true });
  const capsByWhite = []; const capsByBlack = [];
  for(const mv of hist){
    if(mv.captured){
      // mv.color is mover's color; if white moved and captured, white captured black piece
      if(mv.color === 'w'){ capsByWhite.push(mv.captured); }
      else capsByBlack.push(mv.captured);
    }
  }
  // render small pieces
  capsByWhite.forEach(p=>{
    const el = document.createElement('div'); el.style.width='30px'; el.style.height='30px'; el.style.display='inline-block';
    if(window.__pieces_png_loaded) { const sp=document.createElement('div'); sp.className='piece-sprite w' + p.toUpperCase(); sp.style.width='100%'; sp.style.height='100%'; el.appendChild(sp); }
    else { el.textContent = UNICODE[p.toUpperCase()]; el.style.fontSize='20px'; }
    capturedWhiteEl.appendChild(el);
  });
  capsByBlack.forEach(p=>{
    const el = document.createElement('div'); el.style.width='30px'; el.style.height='30px'; el.style.display='inline-block';
    if(window.__pieces_png_loaded) { const sp=document.createElement('div'); sp.className='piece-sprite b' + p.toUpperCase(); sp.style.width='100%'; sp.style.height='100%'; el.appendChild(sp); }
    else { el.textContent = UNICODE[p.toLowerCase()]; el.style.fontSize='20px'; }
    capturedBlackEl.appendChild(el);
  });
}

/* ============================================================
   Click handling: both boards use same handler; pass 'view' to prefer selecting that color
   ============================================================ */
function onSquareClick(alg, view){
  if(gameOver) return;
  if(!selected){
    const piece = game.get(alg);
    if(!piece) return; // nothing to pick
    // prefer selecting if view matches piece color
    selected = alg;
    highlightMovesFrom(alg);
    return;
  } else {
    // attempt move
    const move = game.move({ from: selected, to: alg, promotion: 'q' });
    selected = null;
    clearHighlights();
    if(!move) return; // illegal -> ignore
    // sound
    if(move.captured) SND.capture(); else SND.move();
    // broadcast move
    broadcastMove(move);
    renderBoards();
    checkEndgame();
  }
}

/* set up clicks on generated squares */
function hookBoardClicks(){
  boardWhiteEl.querySelectorAll('.sq').forEach(sq => {
    sq.onclick = () => onSquareClick(sq.dataset.square, 'white');
  });
  boardBlackEl.querySelectorAll('.sq').forEach(sq => {
    sq.onclick = () => onSquareClick(sq.dataset.square, 'black');
  });
}

/* ========== clocks (classic countdown, switches on move) ========== */
function startClockTicker(){
  if(clockInterval) clearInterval(clockInterval);
  lastTick = performance.now();
  clockInterval = setInterval(()=>{
    if(gameOver) return;
    const now = performance.now(); const dt = (now - lastTick) / 1000; lastTick = now;
    const side = game.turn(); // 'w' or 'b'
    clocks[side] -= dt;
    // ticking sound under 10s quietly
    if(Math.floor(clocks[side]) <= 10 && Math.floor(clocks[side]) >= 1) SND.check();
    if(clocks[side] <= 0){
      clocks[side] = 0;
      gameOver = true;
      SND.win(); Confetti.burst(140);
      renderBoards();
      showRematchPromptLocal();
    }
    updateClockDisplays();
  }, 250);
}
function resetClocks(){
  clocks.w = START_CLOCK; clocks.b = START_CLOCK;
  updateClockDisplays();
}

/* when a move is made locally or remote, we re-start clocks (they count down for side to move) */
function afterMoveClock(){
  startClockTicker();
}

/* ========== multiplayer messaging (WS or localStorage fallback) ========== */
function initMultiplayer(){
  if(MULTIPLAYER_WS_URL){
    try{
      ws = new WebSocket(MULTIPLAYER_WS_URL);
      ws.onopen = ()=>{ usingWS = true; mpStatusEl.textContent = 'connected (ws)'; };
      ws.onclose = ()=>{ usingWS = false; mpStatusEl.textContent = 'disconnected (ws)'; };
      ws.onerror = ()=>{ usingWS = false; mpStatusEl.textContent = 'ws error'; };
      ws.onmessage = ev => {
        try{ const msg = JSON.parse(ev.data); handleRemoteMessage(msg); }catch(e){}
      };
    }catch(e){ usingWS = false; mpStatusEl.textContent = 'ws failed'; }
  } else {
    usingWS = false; mpStatusEl.textContent = 'local/offline';
    window.addEventListener('storage', e=>{
      if(e.key === 'chess_move'){
        const payload = JSON.parse(e.newValue || 'null');
        if(payload && payload.signature !== localSig()) applyRemoteMove(payload.move);
      }
      if(e.key === 'chess_rematch'){
        const payload = JSON.parse(e.newValue || 'null');
        if(payload && payload.signature !== localSig()) showRematchPromptLocal();
      }
      if(e.key === 'chess_reset'){
        const payload = JSON.parse(e.newValue || 'null');
        if(payload && payload.signature !== localSig()) resetGameLocal();
      }
    });
  }
}

function broadcastMove(move){
  const payload = { type:'move', move, fen: game.fen(), signature: localSig() };
  if(usingWS && ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(payload));
  else localStorage.setItem('chess_move', JSON.stringify(payload));
  afterMoveClock();
}

function applyRemoteMove(move){
  try{
    // ensure move is legal locally
    const attempt = game.move({ from: move.from, to: move.to, promotion: move.promotion || 'q' });
    if(attempt){
      SND.move();
      renderBoards();
      checkEndgame();
    }
  }catch(e){}
}

function handleRemoteMessage(msg){
  if(!msg || !msg.type) return;
  if(msg.type === 'move') applyRemoteMove(msg.move);
  else if(msg.type === 'rematch') showRematchPromptLocal();
  else if(msg.type === 'reset') resetGameLocal();
}

/* rematch flow */
let rematchTimer = null;
function requestRematch(){
  const payload = { type:'rematch', time: Date.now(), signature: localSig() };
  if(usingWS && ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(payload));
  else localStorage.setItem('chess_rematch', JSON.stringify(payload));
  // show local prompt as initiator
  showRematchPromptLocal(true);
}

function showRematchPromptLocal(initiator=false){
  rematchPromptEl.innerHTML = '';
  rematchPromptEl.style.display = 'block';
  let remaining = REMATCH_AUTO_CANCEL;
  const acceptBtn = document.createElement('button'); acceptBtn.textContent = initiator ? 'Start Rematch (you)' : 'Accept Rematch';
  acceptBtn.style.marginRight='8px';
  const declineBtn = document.createElement('button'); declineBtn.textContent = 'Decline';
  acceptBtn.onclick = ()=>{ sendRematchAccept(); rematchPromptEl.style.display='none'; clearInterval(rematchTimer); };
  declineBtn.onclick = ()=>{ rematchPromptEl.style.display='none'; clearInterval(rematchTimer); };
  rematchPromptEl.appendChild(document.createTextNode('Rematch requested ')); rematchPromptEl.appendChild(acceptBtn); rematchPromptEl.appendChild(declineBtn);
  const cnt = document.createElement('div'); cnt.style.marginTop='6px'; cnt.style.fontSize='12px'; cnt.textContent = `Auto-cancel in ${remaining}s`; rematchPromptEl.appendChild(cnt);
  clearInterval(rematchTimer);
  rematchTimer = setInterval(()=>{ remaining--; if(remaining<=0){ rematchPromptEl.style.display='none'; clearInterval(rematchTimer); } else cnt.textContent = `Auto-cancel in ${remaining}s`; }, 1000);
}

function sendRematchAccept(){
  const payload = { type:'reset', signature: localSig() };
  if(usingWS && ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(payload));
  else localStorage.setItem('chess_reset', JSON.stringify(payload));
  resetGameLocal();
}

function resetGameLocal(){
  game.reset(); selected = null; gameOver = false; resetClocks(); renderBoards();
}

/* local signature to avoid self-triggering */
function localSig(){ return (navigator.userAgent||'') + '::' + location.href; }

/* ========== endgame detection ========== */
function checkEndgame(){
  if(game.game_over()){
    gameOver = true;
    if(game.in_checkmate()) SND.win(), Confetti.burst(120);
    else SND.check();
    // show rematch UI
    showRematchPromptLocal();
    // stop clocks
    if(clockInterval) clearInterval(clockInterval);
  } else {
    // continue ticking
    afterMoveClock();
  }
}

/* ========== UI bindings ========== */
document.getElementById('flipBtn').onclick = ()=>{ // flip displays by toggling CSS order
  // simple visual flip: swap child order of boards container
  const boards = document.getElementById('boards');
  const white = document.getElementById('whiteWrap'), black = document.getElementById('blackWrap');
  boards.insertBefore(black, white);
};
document.getElementById('resignBtn').onclick = ()=>{
  if(gameOver) return;
  gameOver = true;
  SND.win(); Confetti.burst(90);
  showRematchPromptLocal();
};
document.getElementById('offerDraw').onclick = ()=>{ alert('Draw offered (placeholder)'); };
rematchBtn.onclick = ()=> requestRematch();
singleToggle.onclick = ()=>{
  if(mySide === null){ mySide = 'w'; singleToggle.textContent = 'Single-Board: White'; document.getElementById('mpStatus').textContent = 'single-board (white)'; }
  else if(mySide === 'w'){ mySide = 'b'; singleToggle.textContent = 'Single-Board: Black'; document.getElementById('mpStatus').textContent = 'single-board (black)'; }
  else { mySide = null; singleToggle.textContent = 'Single-Board: Off'; document.getElementById('mpStatus').textContent = usingWS ? 'online(ws)' : 'local/offline'; }
  renderBoards();
};

/* ========== initialization ========== */
ensureChessLib(()=> {
  game = new Chess();
  // create grids
  createBoardGrid(boardWhiteEl);
  createBoardGrid(boardBlackEl);
  // color squares (already done via classes in DOM creation)
  hookBoardClicks();
  renderBoards();
  resetClocks();
  startClockTicker();
  initMultiplayer();
});

/* hookBoardClicks re-defined because createBoardGrid created the DOM */
function hookBoardClicks(){
  boardWhiteEl.querySelectorAll('.sq').forEach(sq => { sq.onclick = ()=> { onSquareClick(sq.dataset.square,'white'); }; });
  boardBlackEl.querySelectorAll('.sq').forEach(sq => { sq.onclick = ()=> { onSquareClick(sq.dataset.square,'black'); }; });
}

/* tiny alias to match code above */
function onSquareClick(square, view){ onSquareClickHandler(square, view); }
function onSquareClickHandler(square, view){
  // prefer selecting own-color if view matches; but allow any valid move (pass-and-play)
  if(gameOver) return;
  if(!selected){
    const p = game.get(square);
    if(!p) return;
    selected = square; highlightMovesFrom(square);
  } else {
    const mv = game.move({ from:selected, to:square, promotion:'q' });
    selected = null; clearHighlights();
    if(!mv) return;
    if(mv.captured) SND.capture(); else SND.move();
    broadcastMove(mv);
    renderBoards();
    checkEndgame();
  }
}

/* expose small API for integration later */
window.ChessArena = {
  setMySide: (s)=>{ if(s==='w' || s==='b' || s===null){ mySide=s; renderBoards(); } },
  requestRematch,
  resetGameLocal
};
</script>
</body>
</html>
